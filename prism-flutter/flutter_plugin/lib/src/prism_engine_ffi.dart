import 'dart:ffi';
import 'dart:io';

import 'package:ffi/ffi.dart';

import 'generated/prism_native_bindings.dart';

/// Native (FFI) implementation of PrismEngine.
///
/// Loads [libprism] from the bundle and communicates with the Kotlin/Native
/// C API generated by :prism-native. This implementation is selected when
/// [dart.library.ffi] is available (macOS, Linux, Windows, iOS).
///
/// Engine lifecycle (create → initialize → render loop → destroy) is driven
/// by the caller. The MethodChannel render loop is NOT used for FFI targets.
class PrismEngine {
  PrismEngine() : _bindings = _loadBindings();

  final PrismNativeBindings _bindings;
  int _engineHandle = 0;
  bool _initialized = false;

  static PrismNativeBindings _loadBindings() {
    // On macOS the dylib is embedded by the SPM binary target and auto-loaded
    // by dyld before Dart code runs — use process() to avoid loading a second
    // copy which causes duplicate ObjC class warnings and crashes.
    final lib = Platform.isMacOS
        ? DynamicLibrary.process()
        : Platform.isLinux
            ? DynamicLibrary.open('libprism.so')
            : Platform.isWindows
                ? DynamicLibrary.open('prism.dll')
                : DynamicLibrary.process();
    return PrismNativeBindings(lib);
  }

  // No-op: canvas binding is only needed for the web multi-instance model.
  void attachCanvas(String canvasId) {}

  /// Creates and initializes the native engine (no-op if already initialized).
  Future<void> initialize({String appName = 'Prism', int targetFps = 60}) async {
    if (_initialized) return;
    final nativeName = appName.toNativeUtf8();
    try {
      _engineHandle = _bindings.prism_create_engine(nativeName.cast<Void>(), targetFps);
      _bindings.prism_engine_initialize(_engineHandle);
      _initialized = true;
    } catch (_) {
      if (_engineHandle != 0) {
        _bindings.prism_destroy_engine(_engineHandle);
        _engineHandle = 0;
      }
      rethrow;
    } finally {
      malloc.free(nativeName);
    }
  }

  /// Toggle pause.
  // TODO(prism-native): wire to the native render loop once a frame-tick
  // callback is exposed via the C API.
  Future<void> togglePause() async {}

  /// Returns true once the engine has been created and initialized.
  Future<bool> isInitialized() async => _initialized;

  /// Returns basic engine state.
  Future<Map<String, dynamic>> getState() async => {
        'initialized': _initialized,
        'deltaTime': _bindings.prism_engine_get_delta_time(_engineHandle),
        'totalTime': _bindings.prism_engine_get_total_time(_engineHandle),
        'frameCount': _bindings.prism_engine_get_frame_count(_engineHandle),
      };

  /// Shuts down and destroys the native engine.
  Future<void> shutdown() async {
    if (!_initialized) return;
    _bindings.prism_destroy_engine(_engineHandle);
    _engineHandle = 0;
    _initialized = false;
  }
}
